如何获取一个类对应的字节码文件对象:

class.forName( )方法中一定要填写完整类名（即包名+类名），即便该类与调用forName方法的类在同一包下，也需填写完整类名！而不是绝对路径名

a: 第一种通过Object类中的getClass方法
b:　通过静态属性(class属性) Class<Student> studentClass = Student.class;
c: 通过Class类中的一个静态方法:经常使用
public static Class forName(String className): 
className: 这个表示的是一个类对应的全类名(就是需要加上包名)
Class<?> aClass = Class.forName("org.westos.demo.Student");

-----------------------------

--------------

***构造方法***

============================
  //1.获取空参的构造方法对象
        Constructor<?> constructor = aClass.getConstructor();

        //2.获取一个 参数的构造方法对象 ，参数就是 构造方法的参数的字节码文件类型
        Constructor<?> constructor1 = aClass.getConstructor(String.class);

        //3.获取两个参数的构造方法对象
        Constructor<?> constructor2 = aClass.getConstructor(String.class, int.class);

        //4.获取私有的构造方法对象 getDeclaredConstructor() 获取某个构造方法对象，包括私有的
        // Constructor<?> constructor3 = aClass.getConstructor(String.class, int.class, char.class);只能获取公共的
        Constructor<?> declaredConstructor = aClass.getDeclaredConstructor(String.class, int.class, char.class);

获取所有构造方法
public Constructor<?>[] getConstructors() 获取所有的构造方法不包含私有的
public Constructor<?>[] getDeclaredConstructors() 获取所有的构造方法 包括私有的
B:获取单个构造方法
public Constructor<T> getConstructor(Class<?>... parameterTypes) 获取单个的构造方法 不包含私有的
public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) 获取单个的构造方法包含私有的

=========================

用途：

通过反射获取私有构造方法并使用
编译期无法通过，但是反射是在运行期操作

// 获取字节码文件对象
Class clazz = Class.forName("com.click369.Student") ;
//获取两个形参的构造方法
Constructor con = clazz.getDeclaredConstructor(String.class , int.class) ;
// 值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。

con.setAccessible(true) ; 取消语法检查不然会报错 因为私有的外界不能直接访问

Object obj = con.newInstance("张三" , 23) ;
System.out.println(obj);


---------------------------------

对于空参对象有更便捷的方法，前提是public修饰
//如果使用空参的构造方法创建对象，你直接使用字节码文件对象里面的方法newInstance();就可以了，
        // 不必要再去获取空参的构造方法对象，再调用构造方法对象里面的 getConstructor()
        Object o = aClass.newInstance();
        System.out.println(o);

==========================

***成员变量***


获取所有成员变量
	public Field[] getFields() 获取所有的成员变量包含从父类继承过来的
	public Field[] getDeclaredFields() 获取所有的成员变量 包含私有的 也包含从父类继承过来的成员变量
获取单个成员变量
	public Field getField(String name)
	public Field getDeclaredField(String name)

----------------------------


        //通过反射的方式，来操作成员变量
        Class<?> aClass = Class.forName("org.westos.demo3.Teacher");
        //获取所有的公共的字段对象  Field 这个类型，用来描述成员变量
        Field[] fields = aClass.getFields();
        for (Field field : fields) {
            System.out.println(field);
        }
        System.out.println("===============================");

        //getDeclaredFields(); 获取所有的成员变量对象，包括私有的成员变量
        Field[] declaredFields = aClass.getDeclaredFields();
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }

------------------------------------------
 //通过反射的方式，来操作成员变量
        Class<?> aClass = Class.forName("org.westos.demo3.Teacher");
        Object o1 = aClass.newInstance();
        //获取name这个字段对象
        Field f1 = aClass.getField("name");
        //调用字段对象中的方法，给这个字段设置值
      /*  Constructor<?> declaredConstructor = aClass.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        Object obj = declaredConstructor.newInstance();*/
        //给字段设置
        f1.set(o1, "王五");
        //获取字段的值
        Object o = f1.get(o1);
        System.out.println(o);

// //通过反射的方式，来操作私有成员变量
        Class<?> aClass = Class.forName("org.westos.demo3.Teacher");
        Object obj = aClass.newInstance();

        //获取私有的字段对象
        Field age = aClass.getDeclaredField("age");

        //取消私有权限的检查
        age.setAccessible(true);

        age.setInt(obj, 20);
        int anInt = age.getInt(obj);
        System.out.println(anInt);
----------------
===============

***成员方法***

===============

A:获取所有成员方法
	public Method[] getMethods() //获取所有的公共的成员方法不包含私有的 包含从父类继承过来的过来的公共方法
	public Method[] getDeclaredMethods()//获取自己的所有成员方法 包含私有的
B:获取单个成员方法
	//参数1: 方法名称  参数2:方法行参的class 对象
	public Method getMethod(String name,Class<?>... parameterTypes) //获取单个的方法 不包含私有的
	public Method getDeclaredMethod(String name,Class<?>... parameterTypes) 获取单个方法包括私有的

        //获取不是公共的方法对象以及私有的
        Method hehe = aClass.getDeclaredMethod("hehe", int.class);
        System.out.println(hehe);

--------------------

通过反射获取带参带返回值成员方法并使用
 //获取某个方法对象 参数1：方法名 参数2：可变参数，这个方法的参数的字节码类型
        Class<?> aClass = Class.forName("org.westos.demo4.Person");
        Object obj = aClass.newInstance();
        Method eat = aClass.getMethod("eat", String.class);
 //调用方法对象的方法来让这个方法执行
        eat.invoke(obj, "张三");//方法没有返回值时返回null


方法有返回值的情况
Method sleep = aClass.getMethod("sleep", String.class, int.class);
Object o = sleep.invoke(obj, "万五", 30);System.out.println(o);


私有方法且有返回值的情况
Method hehe = aClass.getDeclaredMethod("hehe", int.class);
//取消私有权限的检查
hehe.setAccessible(true);
Object invoke = hehe.invoke(obj, 10);
System.out.println(invoke);


==============================

***通过反射运行配置文件内容***

==============================
-----------------
配置文件用=连接
不能加引号
-----------------

 //创建属性集合，读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("peizhi.properties"));
        //通过配置文件中配置的类的全限定类名，通过反射来创建该类对象
        Class<?> className = Class.forName(properties.getProperty("className"));
        Object obj = className.newInstance();
        //通过反射来调用该类的方法执行。方法名从配置文件中获取。
        Method methodName = className.getDeclaredMethod(properties.getProperty("methodName"));
        methodName.invoke(obj);

============================

***通过反射越过泛型检查***


============================

泛型在编译期有效，在运行期擦除，而反射发生在运行期

-------------------
给ArrayList<Integer>的一个对象，想在这个集合中添加一个字符串数据，如何实现呢？


        //我想把这个字符串类型加到集合里面，传统的方式不行，你可以使用反射来加进去
        //泛型只在编译期有效，在运行期就擦除了，
        ArrayList<Integer> list = new ArrayList<>();
        list.add(100);
        list.add(200);
        //list.add("abc");
        System.out.println("==========================================");
        //利用反射机制，越过集合的泛型检查
        Class<? extends ArrayList> aClass = list.getClass();
        Method add = aClass.getMethod("add", Object.class);
        add.invoke(list, "abc");
        System.out.println(list);
